#!/usr/bin/env python
# -*- coding: utf-8 -*-
import heapq
from typing import List


# ç”±ç©ºåœ°å’Œå¢™ç»„æˆçš„è¿·å®«ä¸­æœ‰ä¸€ä¸ªçƒã€‚çƒå¯ä»¥å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ»šåŠ¨ï¼Œä½†åœ¨é‡åˆ°å¢™å£å‰ä¸ä¼šåœæ­¢æ»šåŠ¨ã€‚å½“çƒåœä¸‹æ—¶ï¼Œå¯ä»¥é€‰æ‹©ä¸‹ä¸€ä¸ªæ–¹å‘ã€‚
#
#  ç»™å®šçƒçš„èµ·å§‹ä½ç½®ï¼Œç›®çš„åœ°å’Œè¿·å®«ï¼Œæ‰¾å‡ºè®©çƒåœåœ¨ç›®çš„åœ°çš„æœ€çŸ­è·ç¦»ã€‚è·ç¦»çš„å®šä¹‰æ˜¯çƒä»Žèµ·å§‹ä½ç½®ï¼ˆä¸åŒ…æ‹¬ï¼‰åˆ°ç›®çš„åœ°ï¼ˆåŒ…æ‹¬ï¼‰ç»è¿‡çš„ç©ºåœ°ä¸ªæ•°ã€‚å¦‚æžœçƒæ— æ³•åœåœ¨ç›®çš„åœ°ï¼Œè¿”å›ž
#  -1ã€‚
#
#  è¿·å®«ç”±ä¸€ä¸ª0å’Œ1çš„äºŒç»´æ•°ç»„è¡¨ç¤ºã€‚ 1è¡¨ç¤ºå¢™å£ï¼Œ0è¡¨ç¤ºç©ºåœ°ã€‚ä½ å¯ä»¥å‡å®šè¿·å®«çš„è¾¹ç¼˜éƒ½æ˜¯å¢™å£ã€‚èµ·å§‹ä½ç½®å’Œç›®çš„åœ°çš„åæ ‡é€šè¿‡è¡Œå·å’Œåˆ—å·ç»™å‡ºã€‚
#
#
#
#  ç¤ºä¾‹ 1:
#
#  è¾“å…¥ 1: è¿·å®«ç”±ä»¥ä¸‹äºŒç»´æ•°ç»„è¡¨ç¤º
#
# 0 0 1 0 0
# 0 0 0 0 0
# 0 0 0 1 0
# 1 1 0 1 1
# 0 0 0 0 0
#
# è¾“å…¥ 2: èµ·å§‹ä½ç½®åæ ‡ (rowStart, colStart) = (0, 4)
# è¾“å…¥ 3: ç›®çš„åœ°åæ ‡ (rowDest, colDest) = (4, 4)
#
# è¾“å‡º: 12
#
# è§£æž: ä¸€æ¡æœ€çŸ­è·¯å¾„ : left -> down -> left -> down -> right -> down -> rightã€‚
#              æ€»è·ç¦»ä¸º 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12ã€‚
#
#
#
#  ç¤ºä¾‹ 2:
#
#  è¾“å…¥ 1: è¿·å®«ç”±ä»¥ä¸‹äºŒç»´æ•°ç»„è¡¨ç¤º
#
# 0 0 1 0 0
# 0 0 0 0 0
# 0 0 0 1 0
# 1 1 0 1 1
# 0 0 0 0 0
#
# è¾“å…¥ 2: èµ·å§‹ä½ç½®åæ ‡ (rowStart, colStart) = (0, 4)
# è¾“å…¥ 3: ç›®çš„åœ°åæ ‡ (rowDest, colDest) = (3, 2)
#
# è¾“å‡º: -1
#
# è§£æž: æ²¡æœ‰èƒ½å¤Ÿä½¿çƒåœåœ¨ç›®çš„åœ°çš„è·¯å¾„ã€‚
#
#
#
#
#
#  æ³¨æ„:
#
#
#  è¿·å®«ä¸­åªæœ‰ä¸€ä¸ªçƒå’Œä¸€ä¸ªç›®çš„åœ°ã€‚
#  çƒå’Œç›®çš„åœ°éƒ½åœ¨ç©ºåœ°ä¸Šï¼Œä¸”åˆå§‹æ—¶å®ƒä»¬ä¸åœ¨åŒä¸€ä½ç½®ã€‚
#  ç»™å®šçš„è¿·å®«ä¸åŒ…æ‹¬è¾¹ç•Œ (å¦‚å›¾ä¸­çš„çº¢è‰²çŸ©å½¢), ä½†ä½ å¯ä»¥å‡è®¾è¿·å®«çš„è¾¹ç¼˜éƒ½æ˜¯å¢™å£ã€‚
#  è¿·å®«è‡³å°‘åŒ…æ‹¬2å—ç©ºåœ°ï¼Œè¡Œæ•°å’Œåˆ—æ•°å‡ä¸è¶…è¿‡100ã€‚
#
#  Related Topics æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ å›¾ æœ€çŸ­è·¯ å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
#  ðŸ‘ 103 ðŸ‘Ž 0


class Solution:
    def shortestDistance(self, maze: List[List[int]], start: List[int], destination: List[int]) -> int:
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        sr, sc = start
        q = [(0, sr, sc)]
        visted = set()
        R, C = len(maze), len(maze[0])
        while q:
            dis, r, c = heapq.heappop(q)
            visted.add((r, c))
            for i in range(4):
                dr, dc = dirs[i]
                nr, nc = r + dr, c + dc
                step = 1
                if nr < 0 or nc < 0 or nr >= R or nc >= C or maze[nr][nc] == 1:
                    continue
                while 0 <= nr < R and 0 <= nc < C and maze[nr][nc] == 0:
                    step += 1
                    nr += dr
                    nc += dc
                nr -= dr
                nc -= dc
                step -= 1
                if [nr, nc] == destination:
                    return dis + step
                if (nr, nc) not in visted:
                    heapq.heappush(q, (dis + step, nr, nc))
        return -1
