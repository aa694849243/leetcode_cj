# -*- coding: utf-8 -*-
import collections
from typing import List


# åŸå ¡å®ˆå«æ¸¸æˆçš„èƒœåˆ©æ¡ä»¶ä¸ºä½¿æ¶é­”æ— æ³•ä»å‡ºç”Ÿç‚¹åˆ°è¾¾åŸå ¡ã€‚æ¸¸æˆåœ°å›¾å¯è§†ä½œ `2*N` çš„æ–¹æ ¼å›¾ï¼Œè®°ä½œå­—ç¬¦ä¸²æ•°ç»„ `grid`ï¼Œå…¶ä¸­ï¼š
# - `"."` è¡¨ç¤ºæ¶é­”å¯éšæ„é€šè¡Œçš„å¹³åœ°ï¼›
# - `"#"` è¡¨ç¤ºæ¶é­”ä¸å¯é€šè¿‡çš„éšœç¢ç‰©ï¼Œç©å®¶å¯é€šè¿‡åœ¨ **å¹³åœ°** ä¸Šè®¾ç½®éšœç¢ç‰©ï¼Œå³å°† `"."` å˜ä¸º `"#"` ä»¥é˜»æŒ¡æ¶é­”å‰è¿›ï¼›
# - `"S"` è¡¨ç¤ºæ¶é­”å‡ºç”Ÿç‚¹ï¼Œå°†æœ‰å¤§é‡çš„æ¶é­”è¯¥ç‚¹ç”Ÿæˆï¼Œæ¶é­”å¯å‘ä¸Š/å‘ä¸‹/å‘å·¦/å‘å³ç§»åŠ¨ï¼Œä¸”æ— æ³•ç§»åŠ¨è‡³åœ°å›¾å¤–ï¼›
# - `"P"` è¡¨ç¤ºç¬ç§»ç‚¹ï¼Œç§»åŠ¨åˆ° `"P"` ç‚¹çš„æ¶é­”å¯è¢«ä¼ é€è‡³ä»»æ„ä¸€ä¸ª `"P"` ç‚¹ï¼Œä¹Ÿå¯é€‰æ‹©ä¸ä¼ é€ï¼›
# - `"C"` è¡¨ç¤ºåŸå ¡ã€‚
#
# ç„¶è€Œåœ¨æ¸¸æˆä¸­ç”¨äºå»ºé€ éšœç¢ç‰©çš„é‡‘é’±æ˜¯æœ‰é™çš„ï¼Œè¯·è¿”å›ç©å®¶æœ€å°‘éœ€è¦æ”¾ç½®å‡ ä¸ªéšœç¢ç‰©æ‰èƒ½è·å¾—èƒœåˆ©ã€‚è‹¥æ— è®ºæ€æ ·æ”¾ç½®éšœç¢ç‰©å‡æ— æ³•è·èƒœï¼Œè¯·è¿”å› `-1`ã€‚
#
# **æ³¨æ„ï¼š**
# - åœ°å›¾ä¸Šå¯èƒ½æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªå‡ºç”Ÿç‚¹
# - åœ°å›¾ä¸Šæœ‰ä¸”åªæœ‰ä¸€ä¸ªåŸå ¡
#
# **ç¤ºä¾‹ 1**
# >è¾“å…¥ï¼š`grid = ["S.C.P#P.", ".....#.S"]`
# >
# >è¾“å‡ºï¼š`3`
# >
# >è§£é‡Šï¼šè‡³å°‘éœ€è¦æ”¾ç½®ä¸‰ä¸ªéšœç¢ç‰©
# ![image.png](https://pic.leetcode-cn.com/1614828255-uuNdNJ-image.png)
#
#
# **ç¤ºä¾‹ 2ï¼š**
# >è¾“å…¥ï¼š`grid = ["SP#P..P#PC#.S", "..#P..P####.#"]`
# >
# >è¾“å‡ºï¼š`-1`
# >
# >è§£é‡Šï¼šæ— è®ºæ€æ ·ä¿®ç­‘éšœç¢ç‰©ï¼Œå‡æ— æ³•é˜»æŒ¡æœ€å·¦ä¾§å‡ºç”Ÿçš„æ¶é­”åˆ°è¾¾åŸå ¡ä½ç½®
# ![image.png](https://pic.leetcode-cn.com/1614828208-oFlpVs-image.png)
#
# **ç¤ºä¾‹ 3ï¼š**
# >è¾“å…¥ï¼š`grid = ["SP#.C.#PS", "P.#...#.P"]`
# >
# >è¾“å‡ºï¼š`0`
# >
# >è§£é‡Šï¼šæ— éœ€æ”¾ç½®éšœç¢ç‰©å³å¯è·å¾—èƒœåˆ©
# ![image.png](https://pic.leetcode-cn.com/1614828242-oveClu-image.png)
#
# **ç¤ºä¾‹ 4ï¼š**
# >è¾“å…¥ï¼š`grid = ["CP.#.P.", "...S..S"]`
# >
# >è¾“å‡ºï¼š`4`
# >
# >è§£é‡Šï¼šè‡³å°‘éœ€è¦æ”¾ç½® 4 ä¸ªéšœç¢ç‰©ï¼Œç¤ºæ„å›¾ä¸ºæ”¾ç½®æ–¹æ³•ä¹‹ä¸€
# ![image.png](https://pic.leetcode-cn.com/1614828218-sIAYkb-image.png)
#
#
# **æç¤ºï¼š**
# - `grid.length == 2`
# - `2 <= grid[0].length == grid[1].length <= 10^4`
# - `grid[i][j]` ä»…åŒ…å«å­—ç¬¦ `"."`ã€`"#"`ã€`"C"`ã€`"P"`ã€`"S"`
#  Related Topics æ•°ç»„ åŠ¨æ€è§„åˆ’ çŸ©é˜µ
#  ğŸ‘ 3 ğŸ‘ 0

# æœ€å¤§æµ æœ€å°å‰²
class Solution:
    def guardCastle(self, grid: List[str]) -> int:
        C = len(grid[0])
        n = 2 * C  # è®¡ç®—æ€»èŠ‚ç‚¹æ•°é‡ï¼Œå› ä¸ºåé¢éœ€è¦æ‹†èŠ‚ç‚¹ï¼Œå°†ä¸€ä¸ªèŠ‚ç‚¹å˜æˆå…¥ç‚¹å’Œå‡ºç‚¹ï¼Œæ‰€ä»¥æœ€ç»ˆçš„æ€»èŠ‚ç‚¹æ•°å…¶å®æ˜¯4*C
        cap = collections.defaultdict(int)  # å®šä¹‰ä¸¤ä¸ªèŠ‚ç‚¹çš„æµé‡
        f = {}
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        inf = 20010

        def cal(i, j):  # å°†2ç»´æ•°æ®è½¬ä¸º1ç»´
            if (i, j) in f:
                return f[i, j]
            return i * C + j

        g = collections.defaultdict(list)  # è¾¹è¡¨çš„å›¾
        devil = -2  # å®šä¹‰è¶…çº§æ¶é­”èŠ‚ç‚¹
        gate = -1  # å®šä¹‰è¶…çº§ä¼ é€é—¨èŠ‚ç‚¹
        for r in range(2):  # æ„å»ºè¾¹è¡¨
            for c in range(C):
                if grid[r][c] == '#':
                    continue
                num = cal(r, c)
                g[num].append(num + n)  # æ‰€æœ‰çš„é#èŠ‚ç‚¹éƒ½ç»™ä»–å¢åŠ ä¸€æ¡è¾¹ï¼Œä¹Ÿå°±æ˜¯èŠ‚ç‚¹å…¥å£->èŠ‚ç‚¹å‡ºå£ï¼Œå…¶å®å¹¶ä¸æ˜¯æ‰€æœ‰èŠ‚ç‚¹éƒ½éœ€è¦è¿™ä¹ˆåšï¼Œæˆ‘è¿™ä¹ˆå†™çº¯ç²¹æ˜¯ä¸ºäº†æ–¹ä¾¿
                if grid[r][c] == '.':
                    cap[num, num + n] = 1  # è®¾ç½®èŠ‚ç‚¹é—´çš„æµé‡ï¼Œå¦‚æœæ˜¯.å·ï¼Œé‚£ä¹ˆæµé‡æ˜¯1ï¼Œ
                elif grid[r][c] == 'P':  # é‡åˆ°ä¼ é€é—¨çš„æƒ…å†µ
                    cap[num, num + n] = inf  # èŠ‚ç‚¹å…¥å£->å‡ºå£æµé‡è®¾ç½®ä¸ºinf
                    cap[num + n, gate] = inf  # èŠ‚ç‚¹å‡ºå£->è¶…çº§ä¼ é€é—¨ï¼Œæµé‡åŒæ ·è®¾ç½®ä¸ºinf
                    cap[gate, num] = inf  # è¶…çº§ä¼ é€é—¨->èŠ‚ç‚¹å…¥å£ï¼Œæµé‡ä¸ºinf
                    g[num + n].append(gate)  # ç»™èŠ‚ç‚¹å‡ºå£å’Œè¶…çº§ä¼ é€é—¨åŠ ä¸€æ¡è¾¹
                    g[gate].append(num)  # è¶…çº§ä¼ é€é—¨ä¹Ÿå’ŒèŠ‚ç‚¹å…¥å£åŠ ä¸€æ¡è¾¹
                elif grid[r][c] == 'S':  # é‡åˆ°æ¶é­”èŠ‚ç‚¹
                    cap[num, num + n] = inf
                    cap[num + n, devil] = inf  # ä¼ é€åˆ°è¶…çº§æ¶é­”èŠ‚ç‚¹
                    cap[devil, num] = inf
                    g[num + n].append(devil)  # å› ä¸ºè¶…çº§æ¶é­”èŠ‚ç‚¹æ˜¯ç»ˆç‚¹ï¼Œæ‰€ä»¥ä¸ç”¨ä¼ é€å›æ¥
                elif grid[r][c] == 'C':  # èµ·å§‹èŠ‚ç‚¹ï¼Œä¸ºäº†ç»Ÿä¸€ï¼Œæˆ‘ä¹Ÿå°†èµ·å§‹èŠ‚ç‚¹æ‹†ä¸ºå…¥å£å’Œå‡ºå£äº†
                    src = num
                    cap[num, num + n] = inf
                for dr, dc in dirs:  # éå†å››ä¸ªæ–¹å‘
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < 2 and 0 <= nc < C and grid[nr][nc] != '#':
                        nnum = cal(nr, nc)  # é‚»æ¥èŠ‚ç‚¹çš„å…¥å£æ•°å­—
                        cap[num + n, nnum] = inf  # ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å‡ºå£->è¯¥èŠ‚ç‚¹çš„å…¥å£ï¼Œæµé‡åŒæ ·è®¾ç½®ä¸º1
                        g[num + n].append(nnum)

        def bfs():  # bfsæ˜¯ä¸ºäº†è§‚å¯Ÿèµ·å§‹ç‚¹èƒ½å¦åˆ°è¾¾è¶…çº§æ¶é­”èŠ‚ç‚¹ï¼Œå¦‚æœå¯ä»¥åˆ°è¾¾ï¼Œè¯´æ˜è¿˜è¦ç»§ç»­å‰²è¾¹
            dist = collections.defaultdict(lambda: -1)  # å®šä¹‰ä¸€ä¸ªå±‚æ¬¡çš„åˆ—è¡¨ï¼Œé˜²æ­¢æŸä¸€èŠ‚ç‚¹é‡å¤éå†ï¼Œå¹¶å®šä¹‰å„èŠ‚ç‚¹çš„å±‚æ¬¡
            q = collections.deque([src])
            dist[src] = 0
            while q:  # ç®€å•çš„bfs
                node = q.popleft()
                for nxt in g[node]:
                    if dist[nxt] == -1 and cap[node, nxt] > 0:
                        dist[nxt] = dist[node] + 1
                        if nxt == devil:
                            return dist
                        q.append(nxt)
            return dist

        def dfs(node, flow):  # åˆ©ç”¨dfsè¿›è¡Œæœ€å¤§æµé‡è®¡ç®—ï¼Œæœ€å¤§æµé‡å°±æ˜¯æœ€å°å‰²è¾¹
            if node == -2:  # åˆ°è¾¾ç»ˆç‚¹ï¼Œæ­¤æ¬¡æœ€å¤§æµé‡è®¡ç®—å®Œæˆ
                return flow
            delta = flow  # åŸæµé‡
            for nxt in g[node]:
                if dist[nxt] == dist[node] + 1 and cap[node, nxt] > 0:  # åªæœ‰ä¸‹ä¸€å±‚æ¬¡çš„èŠ‚ç‚¹æ‰èƒ½è¿›è¡Œéå†
                    a = dfs(nxt, min(delta, cap[node, nxt]))  # è¯¥èŠ‚ç‚¹å‡ºå»çš„å¯ä»¥å‰²æ‰çš„æµé‡
                    if a:
                        cap[node, nxt] -= a  # æ­£å‘æµé‡å‡å°‘
                        cap[nxt, node] += a  # é€†å‘æµé‡å¢åŠ ï¼Œè¿™ä¸€æ­¥å¿…ä¸å¯å°‘ï¼Œä¸æ‡‚çš„å¯ä»¥ç”¨è¿™ä¸ªä¾‹å­debugä¸€ä¸‹ï¼Œ["CP....", "##.S.P"]ï¼Œæ­£ç¡®ç»“æœæ˜¯3ï¼Œä¸åŠ é€†å‘è¾¹çš„è¯ç»“æœä¼šæ˜¯2
                        if cap[nxt, node] > 0:  # å› ä¸ºé€†å‘æµé‡å¢åŠ äº†ï¼ŒnxtèŠ‚ç‚¹å°±æ–°å¢åŠ äº†ä¸€æ¡è¾¹
                            g[nxt].append(node)
                        delta -= a
                        if delta == 0:  # æ²¡æµé‡å¯ä»¥å‰²äº†å°±æå‰ç»“æŸå§
                            return flow
            return flow - delta  # æ€»æµé‡-å‰©ä¸‹çš„æµé‡=å‰²æ‰çš„æµé‡

        ans = 0
        while ans < inf:
            dist = bfs()  # è¿”å›ä¸€ä¸ªæ–°çš„å±‚æ¬¡åˆ—è¡¨
            if dist[devil] == -1:  # å¦‚æœä»ç„¶å¯è¾¾æœ€ç»ˆèŠ‚ç‚¹ï¼Œè¯´æ˜è¿˜è¦ç»§ç»­å‰²ï¼Œåä¹‹å°±ä¸ç”¨å‰²äº†
                break
            ans += dfs(src, inf)
        return ans if ans < inf else -1  # å¦‚æœæœ€åè®¡ç®—çš„æœ€å¤§æµä¸ºinfï¼Œè¯´æ˜å·²ç»è§¦ç¢°åˆ°äº†è®¾ç½®çš„å±éšœï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰åŠæ³•é˜»æ­¢åˆ°è¾¾æœ€ç»ˆèŠ‚ç‚¹äº†


# åŠ¨æ€è§„åˆ’
# https://leetcode-cn.com/problems/7rLGCR/solution/lcp-38-shou-wei-cheng-bao-by-zerotrac2-kgv2/
class Solution:
    def guardCastle(self, grid: List[str]) -> int:
        C = len(grid[0])
        inf = 20010
        m1 = {'.': 0, 'S': 1, 'C': 2, 'P': 2, '#': 3}  # è®¾ç½®æ˜ å°„è¡¨ï¼Œåˆ†åˆ«è®©ä¼ é€é—¨ä»£è¡¨æ¶é­”æˆ–è®©ä¼ é€é—¨ä»£è¡¨åŸå ¡ï¼Œæ€è·¯æ˜¯é˜»æ­¢æ¶é­”é è¿‘ä¼ é€é—¨ï¼ˆæ­¤æ—¶åŸå ¡å’Œä¼ é€é—¨è¿é€šï¼‰ï¼Œæˆ–é˜»æ­¢ä¼ é€é—¨é è¿‘åŸå ¡ï¼ˆæ­¤æ—¶ä¼ é€é—¨å’Œæ¶é­”è¿é€šï¼‰
        m2 = {'.': 0, 'S': 1, 'C': 2, 'P': 1, '#': 3}

        def _update(t1, t2, f, extra):  # æ›´æ–°çŠ¶æ€t1,t2åˆ†åˆ«ä»£è¡¨å½“å‰åˆ—ä¸Šä¸‹ä¸¤è¡Œçš„chrï¼Œfä¸ºä¸Šä¸€æ­¥çš„çŠ¶æ€ä»¥åŠå¯¹åº”çš„éœ€è¦åŠ çŸ³å¤´æ¬¡æ•°ï¼Œæ³¨æ„fé‡Œå…¨éƒ¨çš„çŠ¶æ€æ˜¯èƒ½é˜»æ­¢æ¶é­”é è¿‘åŸå ¡çš„çŠ¶æ€
            nf = collections.defaultdict(lambda: inf)  # æ–°çš„çŠ¶æ€å­—å…¸
            if (t1, t2) in {(1, 2), (2, 1)}:  # å½“t1,t2äº’ä¸ºæ¶é­”åŸå ¡ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›ç©ºå­—å…¸ï¼Œä»£è¡¨æ— è®ºå¦‚ä½•éƒ½æ— æ³•é˜»æ­¢æ¶é­”é è¿‘åŸå ¡äº†
                return {}
            for (s1, s2) in f:
                nt1, nt2 = t1, t2  # ä¸´æ—¶å˜é‡å‚¨å­˜t1,t2çš„å€¼ï¼Œå› ä¸ºæ ¹æ®ä¸Šä¸€æ­¥çš„çŠ¶æ€t1,t2å¯èƒ½æ”¹å˜
                if {(s1, nt1), (s2, nt2), (s1, s2)} & {(1, 2), (2, 1)}:  # å¦‚æœå­˜åœ¨æ¶é­”å’ŒåŸå ¡ç›¸é‚»çš„æƒ…å†µï¼Œé‚£ä¹ˆå°±ä¸ç”¨è€ƒè™‘äº†
                    continue
                if nt1 == 0:  # å½“nt1ä¸ºç©ºåœ°ï¼Œè¯´æ˜å¯ä»¥è¢«å·¦è¾¹ä¸€æ ¼ä¼ æŸ“
                    nt1 = s1 if s1 != 3 else nt1
                if nt2 == 0:
                    nt2 = s2 if s2 != 3 else nt2
                nt1 = nt2 if nt1 == 0 and nt2 != 3 else nt1  # nt1å’Œnt2å¯ä»¥äº’ç›¸ä¼ æŸ“
                nt2 = nt1 if nt2 == 0 and nt1 != 3 else nt2
                if (nt1, nt2) in {(1, 2), (2, 1)}:  # å¦‚æœç»è¿‡ä¼ æŸ“åä¸Šä¸‹äº’ä¸ºæ¶é­”åŸå ¡ï¼Œé‚£ä¹ˆè·³è¿‡
                    continue
                nf[nt1, nt2] = min(f[s1, s2] + extra, nf[nt1, nt2])  # æ ¹æ®æƒ…å†µè¡¥çŸ³å¤´
            return dict(nf)

        def merge(li):
            ans = {}
            for t in li:
                ans.update(t)
            return ans

        def solve(m):
            f = {(0, 0): 0}
            for i in range(C):
                t1, t2 = m[grid[0][i]], m[grid[1][i]]
                f1 = _update(t1, t2, f, 0)  # ä¸è¡¥çŸ³å¤´
                f2 = _update(3, t2, f, 1) if t1 == 0 else {}  # è¡¥1é¢—
                f3 = _update(t1, 3, f, 1) if t2 == 0 else {}
                f4 = _update(3, 3, f, 2) if t1 == 0 and t2 == 0 else {}  # è¡¥ä¸¤é¢—
                f = merge([f1, f2, f3, f4])  # åˆå¹¶å­—å…¸
            return min(f.values()) if f else inf #è¿”å›æœ€ç»ˆçŠ¶æ€é‡Œçš„æœ€å°å€¼

        ans = min(solve(m1), solve(m2))
        return ans if ans < inf else -1


Solution().guardCastle(["CP.#.P.", "...S..S"])
# Solution().guardCastle(["CP....", "##.S.P"])
