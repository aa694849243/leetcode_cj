# ä½ çš„èµ›è½¦èµ·å§‹åœç•™åœ¨ä½ç½® 0ï¼Œé€Ÿåº¦ä¸º +1ï¼Œæ­£è¡Œé©¶åœ¨ä¸€ä¸ªæ— é™é•¿çš„æ•°è½´ä¸Šã€‚ï¼ˆè½¦ä¹Ÿå¯ä»¥å‘è´Ÿæ•°æ–¹å‘è¡Œé©¶ã€‚ï¼‰
#
#  ä½ çš„è½¦ä¼šæ ¹æ®ä¸€ç³»åˆ—ç”± Aï¼ˆåŠ é€Ÿï¼‰å’Œ Rï¼ˆå€’è½¦ï¼‰ç»„æˆçš„æŒ‡ä»¤è¿›è¡Œè‡ªåŠ¨é©¾é©¶ ã€‚
#
#  å½“è½¦å¾—åˆ°æŒ‡ä»¤ "A" æ—¶, å°†ä¼šåšå‡ºä»¥ä¸‹æ“ä½œï¼š position += speed, speed *= 2ã€‚
#
#  å½“è½¦å¾—åˆ°æŒ‡ä»¤ "R" æ—¶, å°†ä¼šåšå‡ºä»¥ä¸‹æ“ä½œï¼šå¦‚æœå½“å‰é€Ÿåº¦æ˜¯æ­£æ•°ï¼Œåˆ™å°†è½¦é€Ÿè°ƒæ•´ä¸º speed = -1 ï¼›å¦åˆ™å°†è½¦é€Ÿè°ƒæ•´ä¸º speed = 1ã€‚ (å½“å‰æ‰€
# å¤„ä½ç½®ä¸å˜ã€‚)
#
#  ä¾‹å¦‚ï¼Œå½“å¾—åˆ°ä¸€ç³»åˆ—æŒ‡ä»¤ "AAR" å, ä½ çš„è½¦å°†ä¼šèµ°è¿‡ä½ç½® 0->1->3->3ï¼Œå¹¶ä¸”é€Ÿåº¦å˜åŒ–ä¸º 1->2->4->-1ã€‚
#
#  ç°åœ¨ç»™å®šä¸€ä¸ªç›®æ ‡ä½ç½®ï¼Œè¯·ç»™å‡ºèƒ½å¤Ÿåˆ°è¾¾ç›®æ ‡ä½ç½®çš„æœ€çŸ­æŒ‡ä»¤åˆ—è¡¨çš„é•¿åº¦ã€‚
#
#  ç¤ºä¾‹ 1:
# è¾“å…¥:
# target = 3
# è¾“å‡º: 2
# è§£é‡Š:
# æœ€çŸ­æŒ‡ä»¤åˆ—è¡¨ä¸º "AA"
# ä½ç½®å˜åŒ–ä¸º 0->1->3
#
#
#  ç¤ºä¾‹ 2:
# è¾“å…¥:
# target = 6
# è¾“å‡º: 5
# è§£é‡Š:
# æœ€çŸ­æŒ‡ä»¤åˆ—è¡¨ä¸º "AAARA"
# ä½ç½®å˜åŒ–ä¸º 0->1->3->7->7->6
#
#
#  è¯´æ˜:
#
#
#  1 <= targetï¼ˆç›®æ ‡ä½ç½®ï¼‰ <= 10000ã€‚
#
#  Related Topics å † åŠ¨æ€è§„åˆ’
#  ğŸ‘ 95 ğŸ‘ 0
import heapq


# 1dijsktra
class Solution(object):
    def racecar(self, target):
        K = target.bit_length()
        one_distance = 1 << K  # ä¸€æ¬¡èƒ½èµ°çš„æœ€è¿œè·ç¦»ï¼Œå‡å¦‚target=5ä¸€æ¬¡æœ€è¿œèµ°8,ç´¯ç§¯æœ€é•¿èµ°16
        barrier = 1 << (K + 1)
        distances = [float('inf')] * (2 * barrier + 1)  # ä¸€ä¸ªå°çŸ¥è¯†ï¼Œå¦‚æœåˆ—è¡¨é•¿åº¦ä¸ºå¥‡æ•°ï¼Œdistance[x]!=distance[-x]
        distances[target] = 0  # distances[i]ä»£è¡¨è·ç¦»ç›®æ ‡è·ç¦»ä¸ºiï¼Œvalä¸ºç”¨çš„æœ€å°‘æ­¥æ•°
        q = [(0, target)]
        while q:
            steps, tr = heapq.heappop(q)
            # if distances[tr] < steps:  # å¦‚æœdistance[tr]<stepsï¼Œè¯´æ˜å·²ç»æœ‰æ›´æ—©çš„æ­¥æ•°åˆ°è¾¾träº†ï¼Œä¸å¿…å†é‡å¤è®¿é—®äº†
            #     continue
            if tr == 0:
                return steps
            for k in range(K + 1):
                walk = 2 ** k - 1  # èµ°äº†walkæ­¥ï¼Œè®°ä¸ºA^kRï¼ŒRä¸ºè½¬å‘
                tr2 = walk - tr  # å¦‚æœwalkè¶…è¿‡trï¼Œç»è¿‡ä¸€æ¬¡Rè½¬å‘åï¼Œä¸‹ä¸€æ¬¡èµ°ä¾æ—§æ˜¯æ­£å‘ï¼Œå¦‚æœwalkæ²¡è¶…è¿‡trï¼Œææ—©è½¬å‘äº†ï¼Œåé¢èµ°å°±æ˜¯èƒŒé“è€Œé©°ï¼Œtr2å°±ä¸ºè´Ÿæ•°
                nxt_steps = steps + k + 1  # å› ä¸ºæ¯æ¬¡çš„æ­¥é•¿æœ€å°‘éƒ½æ˜¯1
                if tr2 == 0:
                    nxt_steps -= 1  # å¦‚æœå·²ç»åˆ°è¾¾ç›®çš„åœ°äº†ï¼Œå°‘ä¸€ä¸ªRå­—æ®µ
                if abs(tr2) <= barrier and distances[tr2] > nxt_steps:
                    distances[tr2] = nxt_steps
                    heapq.heappush(q, (nxt_steps, tr2))


# 2åŠ¨æ€è§„åˆ’
class Solution(object):
    def racecar(self, target):
        dp = [0, 1, 4] + [float('inf')] * (target - 2)
        for t in range(3, target + 1):  # ä¸¤ç§æƒ…å†µ 1 A^k-1Ræœªåˆ°è¾¾ç›®çš„åœ°ï¼ŒæŠ˜è¿”A^jRåå†è·‘åˆ°t
            k = t.bit_length()  # 2  A^kRè¶…è¿‡ç›®çš„åœ°æŠ˜è¿”
            if t == 2 ** k - 1:
                dp[t] = k
                continue
            for j in range(k - 1):
                dp[t] = min(dp[t], dp[t - 2 ** (k - 1) + 2 ** j] + k - 1 + j + 2)
            if 2 ** k - 1 - t < t:  # å›æ»šè·ç¦»å°äºt
                dp[t] = min(dp[t], dp[2 ** k - 1 - t] + k + 1)
        return dp[target]


Solution().racecar(6)
